<?php

/**--------------------------------------------------------------------------------------------------------------------------------------------//

// В этой главе мы рассмотрим следующие вопросы 

• Шаблон Singleton. Специальный класс, формирующий один и только один экземпляр объекта.

• Шаблон Factory Method. Создание иерархии наследования классов создателя.

• Шаблон Abstract Factory. Создание групп функционально связанных программных продуктов.


//--------------------------------------------------------------------------------------------------------------------------------------------//

// Формирование задач 

В предыдущей главе мы описали принцип программирования на основе интерфейса, а не его реализации, побуждающий нас 
оперироватьабстрактными супертипами в рассматриваемых здесь классах. Ведь этоделает код более гибким, позволяя применять 
объекты, экземпляры которых получаются из разных конкретных подклассов 

ПРИМЕРЫ: uploads/gl9/form

Инстанцируя объект типа Minion непосредственно в классе NastyBoss, мы ограничиваем гибкость последнего. 
Вот если бы объект NastyBoss Moг оперировать любым экземпляром объекта типа Employee, мы могли бы сделать
код доступным для изменения непосредственно во время выполнения программы, просто добавляя дополнительные
специализации класca Employee. Полиморфизм, представленный на рис. 9.1, должен выглядеть для вас уже знакомым.


//--------------------------------------------------------------------------------------------------------------------------------------------//

// Шаблон Singleton


// Проблемы

Итак, выделим действующие факторы рассматриваемой здесь проблемы.
• Объект типа Preferences должен быть доступен любому объекту в проектируемой системе.
• Объект типа Preferences не должен сохраняться в глобальной переменной, значение которой может быть случайно перезаписано.
• В проектируемой системе не должно быть больше одного объекта типа Preferences. Это означает, что объекту может установить
свойство в объекте типа Preferences, a о б ъ к Z- извлечь то же самое значение этого свойства, причем без непосредственного 
взаимодействия объектов между собой (предполагается, что оба эти объекта имеют доступ к объекту типа Preferences).


// Реализация 

Создадим для этого класс, экземпляр которого нельзя получить за его пределами. 
На первый взгляд может по-эказаться, что сделать это трудно. Но на самом деле это лишь вопрос определения закрытого 
конструктора и добавим статический метод и функцию, что бы получить экземпляр класса

ПРИМЕРЫ: uploads/gl9/singleton


Когда применяется шаблон Singleton, зависимость скрыта в теле метода и не объявляется в его сигнатуре. 
Это затрудняет отслеживание связей в системе, поэтому классы-синглтоны должны применяться редко и оченьосторожно.
Тем не менее я считаю, что умеренное использование шаблона Singleton может улучшить 
проектирование системы, избавив ее от излишнего загромождения при передаче ненужных объектов в системе.
Объекты-синглтоны являются шагом вперед по сравнению с применением глобальных переменных в объектно-ориентированном 
контексте, поскольку перезаписать такие объекты неправильными данными нельзя.


//--------------------------------------------------------------------------------------------------------------------------------------------//

// Шаблон Factory Method

Шаблон Factory Method (Фабричный метод) решает задачу получения экземпляров объектов, когда в исходном коде
применяются абстрактные типы. В чем же состоит решение? Оно состоит в том, чтобы поручить получение 
экземпляров объектов специальным классам.


// Проблемы 

Рассмотрим проект личного органайзера. Среди прочего в нем придется иметь дело с 
объектом типа Appointment, представляющего назначенную встречу. Допустим, что бизнес-группа
нашей компании установила взаимоотношения сдругой компанией, инам поручено передать им информацию 
оназначенной встречев формате BloggsCal. Но нас предупредили, что со временем могут понадобиться идругие форматы.

Используя терминологию данного шаблона, можно сказать, что класс CommsManager - это 
производитель, а класс ApptEncoder - продукт.


// Реализация 

В шаблоне Factory Method классы производителей отделены от продуктов, которые они должны формировать. 

Производитель - это класс фабрики, в котором определен метод для генерации объекта отдельного продукта. 
Если стандартная реализация этого метода не предусмотрена, то создание экземпляров объектов поручается 
дочерним классам производителя. Как правило, в каждом подклассе производителя получается экземпляр 
параллельного дочернего класса продукта.

Переопределим класс CommsManager как абстрактный. Таким образом,
мы сохраним гибкий суперкласс и разместим весь код, связанный с конкретным протоколом, 
в отдельных подклассах (рис. 9.4). Ниже приведен пример несколько упрощенного кода:

ПРИМЕРЫ: uploads/gl9/FactoryMethod


// Следствия 

Обратитевнимание на то, что классы производителей отражают иерархию продуктов. Это обычный результат,
получаемый в результате применения шаблона Factory Method. 

Некоторые программисты считают этот шаблон особым видом дублирования кода и поэтому часто испытывают к нему антипатию. 

Еще один недостаток шаблона Factory Method заключается в том, что он нередко способствует ненужной 
подклассификации. Следовательно, если применение шаблона Factory Method не предполагается для формирования
подклассов производителей, а иных причин для его использования не существует, то рекомендуется сначала хорошенько подумать. 

Именно поэтому мы продемонстрировали в приведенном выше примере ограничения, 
которые накладывает поддержка верхнего и нижнего колонтитулов.

В данном примере мы сосредоточились только на поддержке данных для назначенных встреч. 
Если же немного расширить этот пример, включив в него элементы заданий и контактов, то можно столкнуться 
с новой проблемой. Нам понадобится структура, которая должна одновременно обращаться с целым рядом связанных реализаций. 

Поэтому шаблон Factory Method не редко применяется вместе с шаблоном Abstract Factory, как поясняется в следующем разделе.


//--------------------------------------------------------------------------------------------------------------------------------------------//

// Шаблон Abstract Factor 

// Реализация 

ПРИМЕРЫ: uploads/gl9/AbstractFactor

// Следствие 

Так что же дает применение шаблона Abstract Factory?

• Во-первых, мы отвязали проектируемую систему от подробностей реализации. 
В данном примере можно добавлять или удалять любое количество форматов кодирования, не опасаясь каких-нибудь осложнений.

• Во-вторых, мы ввели в действие группу функционально связанных элементов проектируемой системы. 
Поэтому применение класса BloggsCommsManager гарантирует, что работать придется только с классами, связанными сформатом BloggsCal.

• В-третьих, добавление новых продуктов может оказаться затруднительным. 
Для этого нам придется не только создать конкретные реализации новых продуктов, но и внести изменения в абстрактный
класс производителя, а также создать каждый конкретный реализатор, чтобы его поддержать.



//--------------------------------------------------------------------------------------------------------------------------------------------//*/