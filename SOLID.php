<?php 

/**---------------------------------------------------------------------------------------------------------//

Single Responsibility Principle («Принцип единой ответственности», SRP)
Open-Closed Principle («Принцип открытости-закрытости», OCP)
Liskov Substitution Principle («Принцип подстановки Барбары Лисков», LSP)
Interface Segregation Principle («Принцип разделения интерфейса», ISP)
Dependency Inversion Principle («Принцип инверсии зависимостей», DIP)


//---------------------------------------------------------------------------------------------------------//

// Принцип единой ответственности SRP

Принцип единственной ответственности гласит, что класс должен делать какое-то одно действие и,
соответственно, для его изменения должна быть только одна причина.

Во-первых, когда несколько разных команд могут работать над одним проектом и редактировать один
и тот же класс по многим причинам, это может привести к несовместимости модулей.

Во-вторых, следование этому принципу облегчает контроль версий. Скажем, у нас есть класс для 
обработки операций базы данных, и мы видим изменение в этом файле в коммитах на GitHub. 
Если мы последовательно придерживаемся принципа SRP, мы можем быть уверены, что это изменение
касается хранения данных или вещей, связанных с базой данных.

// Пример

У нас есть класс Book и класс Shop, для того, что бы не нарушать принцип SRP, надо разделять одну
функцию на класс, т.е. не вмещать в один класс и вывод данных, и запись в txt, xml, БД и т.д.
Для этого создаются подклассы с единым функционалом, идём далее


//---------------------------------------------------------------------------------------------------------//

// Принцип открытости-закрытости OCP

В общем, этот принцип имеет в виду следующее: у нас должна быть возможность добавлять новый 
функционал, не трогая существующий код класса. Это связано с тем, что когда мы модифицируем 
существующий код, мы рискуем создать потенциальные баги. Поэтому следует по возможности избегать
прикасаться к протестированному и надежному (в целом) коду в продакшене.

Но как же добавить новый функционал, не прикасаясь к классу? Обычно это делается при помощи 
интерфейсов и абстрактных классов.

// Пример 

См. uploands__solid/open-close.jpg - UML


//---------------------------------------------------------------------------------------------------------//

// Принцип постановки LSP

РОДИТЕЛЬСКИЙ КЛАСС НЕ ДОЛЖЕН ЗАВИСЕТЬ ОТ ДОЧЕРНЕГО

Это означает следующее. Если у нас есть класс B, являющийся подклассом класса A, у
нас должна быть возможность передать объект класса B любому методу, который ожидает
объект класса A, причем этот метод не должен выдать в таком случае какой-то странный output.

Это ожидаемое поведение, потому что когда мы используем наследование, мы предполагаем,
что дочерний класс наследует все, что есть у суперкласса. Дочерний класс расширяет поведение, 
то никогда не сужает его.

Если класс не подчиняется принципу подстановки Барбары Лисков, это приводит к неприятным ошибкам,
которые трудно обнаружить.


//---------------------------------------------------------------------------------------------------------//

// Принцип разделения интерфейсов ISP

Этот принцип гласит: много клиентоориентированных интерфейсов лучше, чем один интерфейс 
общего назначения. Клиенты не должны принуждаться к реализации функций, которые им не нужны.

Этот принцип прост как для понимания, так и для применения

// Пример

См. uploads_solid/segreg-interface.jpg - UML

Теперь наша модель куда более гибкая и расширяемая. Клиентам не нужно реализовывать никакую
нерелевантную логику, потому что в интерфейсе парковки мы предоставили только 
функционал, касающийся самой парковки.


//---------------------------------------------------------------------------------------------------------//

// Принцип инверсии зависимостей

Принцип инверсии зависимостей гласит, что наши классы должны зависеть от интерфейсов или
абстрактных классов, а не от конкретных классов и функций.

(OCP — принцип открытости-закрытости, а DIP — принцип инверсии зависимостей).

Эти два принципа, безусловно, связаны друг с другом, и мы уже применяли этот шаблон, 
когда обсуждали принцип открытости-закрытости.

//--------------------------------------------------------------------------------------------------------**/